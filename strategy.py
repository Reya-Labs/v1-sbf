from abc import ABCMeta, abstractmethod
from signal import signal
from turtle import pos
from sqlalchemy import column
from event import SignalEvent

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular tokens based on the inputs of rates
    generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the rate tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self, event):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

class LongRateStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG (VT) all of the
    tokens as soon as a rate is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, rates, events):
        """
        Initialises the long rate strategy.

        Parameters:
        rates - The DataHandler object that provides rate information
        events - The Event Queue object.
        """
        self.rates = rates
        self.token_list = self.rates.token_list
        self.events = events

        # Once long (vt) & hold signal is given, these are set to True
        self.aped = self._calculate_initial_aped()

    def _calculate_initial_aped(self):
        """
        Adds keys to the aped dictionary for all tokens
        and sets them to False.
        """
        aped = {}
        for t in self.token_list:
            aped[t] = False
        return aped

    def calculate_signals(self, event):
        """
        For "VT and Hold" we generate a single signal per token
        and then no additional signals. This means we are
        constantly long the underlying rates market
        from the date of strategy initialisation.

        Parameters
        event - A MarketEvent object
        """
        if event.type == 'MARKET':
            for t in self.token_list:
                rates = self.rates.get_latest_rates(t, N=1)
                if rates is not None and rates != []:
                    if not self.aped[t]:
                        # (Token, Direction = LONG, SHORT or EXIT, Timestamp)
                        signal = SignalEvent(rates[0][0], 'LONG', rates[0][1])
                        self.events.put(signal)
                        self.aped[t] = True