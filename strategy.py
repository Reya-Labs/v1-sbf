from abc import ABCMeta, abstractmethod
from matplotlib.cbook import Stack
import numpy as np
from event import SignalEvent

SECONDS_IN_YEAR = 31536000

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular tokens based on the inputs of rates
    generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the rate tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self, event):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

class LongShortMomentumStrategy(Strategy):
    """
    A basic time series momentum (i.e. trend-following) strategy using a 
    lookback window to compute the moving average of the rate. If current rate
    if above the moving average + buffer, then go long (VT), else short (FT) if 
    it's below moving average - buffer. In the +/- buffer region around the moving 
    average we don't hold a position, and the exuction handler exits the trade.
    """

    def __init__(self, rates, events, trend_lookback=30, apy_lookback=1, buffer=1):
        
        self.rates = rates
        self.token_list = self.rates.token_list
        self.events = events
        self.trend_lookback = trend_lookback
        self.apy_lookback = apy_lookback
        self.buffer = buffer

    def calculate_signals(self, event):
        if event.type == "MARKET":
            for t in self.token_list:
                liquidity_indexes = self.rates.get_latest_rates(t, N=self.trend_lookback+1) # List of (token, timestamp, liquidity index) tuples
                rates = self.liquidity_index_to_apy(liquidity_indexes) # Convert to APYs
                if rates is not None and rates != []:
                    moving_average, moving_buffer = self.update_moving_average_and_buffer(rates=rates)
                    # Update the position using the momentum
                    position = "EXIT"
                    if rates[-1] > moving_average + moving_buffer:
                        position = "LONG"
                    if rates[-1] < moving_average - moving_buffer:
                        position = "SHORT"
                    
                    signal = SignalEvent(liquidity_indexes[-1][0], position, liquidity_indexes[-1][1])
                    self.events.put(signal)

    def liquidity_index_to_apy(self, rates):
        liq_idx = np.array([r[2] for r in rates])
        timestamps = np.array([r[1] for r in rates])
        apys = []
        for i in range(1, len(liq_idx)):
            window = i-self.apy_lookback if self.apy_lookback<=i else 0
            variable_rate = liq_idx[i]/liq_idx[window] - 1.0 
            # Annualise the rate
            compounding_periods = SECONDS_IN_YEAR / (timestamps[i] - timestamps[window]).total_seconds()
            apys.append(((1 + variable_rate)**compounding_periods) - 1)
        return np.array(apys)

    def update_moving_average_and_buffer(self, rates):
        previous_rates = rates[:-1]
        moving_average = previous_rates.mean()
        moving_buffer = self.buffer * previous_rates.std()
        return moving_average, moving_buffer
    

class LongRateStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG (VT) all of the
    tokens as soon as a rate is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, rates, events):
        """
        Initialises the long rate strategy.

        Parameters:
        rates - The DataHandler object that provides rate information
        events - The Event Queue object.
        """
        self.rates = rates
        self.token_list = self.rates.token_list
        self.events = events

        # Once long (vt) & hold signal is given, these are set to True
        self.aped = self._calculate_initial_aped()

    def _calculate_initial_aped(self):
        """
        Adds keys to the aped dictionary for all tokens
        and sets them to False.
        """
        aped = {}
        for t in self.token_list:
            aped[t] = False
        return aped

    def calculate_signals(self, event):
        """
        For "VT and Hold" we generate a single signal per token
        and then no additional signals. This means we are
        constantly long the underlying rates market
        from the date of strategy initialisation.

        Parameters
        event - A MarketEvent object
        """
        if event.type == 'MARKET':
            for t in self.token_list:
                rates = self.rates.get_latest_rates(t, N=1)
                if rates is not None and rates != []:
                    if not self.aped[t]:
                        # (Token, Direction = LONG, SHORT or EXIT, Timestamp)
                        signal = SignalEvent(rates[0][0], 'LONG', rates[0][1])
                        self.events.put(signal)
                        self.aped[t] = True